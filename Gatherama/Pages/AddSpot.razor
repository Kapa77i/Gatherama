@page "/addspots"
@using Gatherama.Shared
@using Microsoft.Maui.Controls.Maps
@using Microsoft.Maui.Maps
@using System.Net.Http
@using System.Text.Json
@using System.Net.Http.Json;
@using System
@using System.Threading.Tasks
@using Microsoft.Maui.Controls
@using Gatherama.Services
@using MongoDB.Bson;
@using Newtonsoft.Json


@inject IJSRuntime JS
@inject ApiService apiService
@inject NavigationManager NavigationManager
@inject LoginState loginstate


<h1>Add Gathering Spot</h1>

<p>Here you can add your new gathering spot!</p>

<!--MAPS SEKOILUJA:
    Tehd‰‰n t‰nne kartta, joka n‰ytt‰‰ vain nykyisen sijainnin ja jossa pystyy syˆtt‰m‰‰n tiedot lˆydˆkselle.
    OwnSpots sivulle tulee kartta, joka n‰ytt‰‰ kaikki lˆydˆkset mit‰ on henkilˆll‰. Sinne myˆs suodattimet esim lajin perusteella, tai
    ett‰ n‰ytt‰‰ myˆs kaverien jakamat paikat.
-->

<head>
    <title>Simple Marker</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBBJYKuoWVsb2MFdchEYIihbAb3pN0fFUg&callback=initMap&libraries=&v=weekly" async defer></script>
    <link rel="stylesheet" href="./style.css" />
    <script src="./app.js"></script>


    <script>

        let markers = [];
    
        function initMap(visiblefindings, person, platform, currentlocation) {

            const geocoder = new google.maps.Geocoder();
          
            const map = new google.maps.Map(document.getElementById("googleMap"), {
                zoom: 12,
                center: { lat: 62.8893928527832, lng: 27.6920166015625 }, //alkukeskitys Kuopioon
                //isShowingUser: true, //turha vai Androidille?
                fullscreenControl: false,
                zoomControl: true,
                streetViewControl: false
            });

            const mush_icon = '../Images_index/mushroom_icon.png'; 
            const berry_icon = '../Images_index/berry_icon.png';
            const blueberry_icon = '../Images_index/blueberry_icon.png';

            map.addListener("click", (e) => {

                placeMarkerAndPanTo(e.latLng, map, geocoder);
                //geocodeLatLng(e.latLng, geocoder, map);
            });

            //To pan to current location
            const locationButton = document.createElement("button");

            locationButton.textContent = "Pan to Current Location";
            locationButton.classList.add("custom-map-control-button");
            map.controls[google.maps.ControlPosition.TOP_CENTER].push(locationButton);
            locationButton.addEventListener("click", () => {

                //jos windows (false) niin k‰ytet‰‰n HTML5 geolocation, muuten android and currentlocation parametri

                // if (platform == false) {

                //     //map.setCenter({ lat: currentlocation.latitude, lng: currentlocation.longitude }); //T‰m‰ toimii myˆs windowsilla

                //     // Try HTML5 geolocation.
                //     if (navigator.geolocation) {
                //         navigator.geolocation.getCurrentPosition(
                //             (position) => {
                //                 const pos = {
                //                     lat: position.coords.latitude,
                //                     lng: position.coords.longitude,
                //                 };

                //                 //window.alert("Position is: " + pos);
                //                 // window.alert("Location found.");
                //                 //infoWindow.open(map);
                //                 map.setCenter(pos);

                //             },
                //             () => {
                //                 handleLocationError(true, infoWindow, map.getCenter());
                //             },
                //         );
                //     } else {
                //         // Browser doesn't support Geolocation
                //         handleLocationError(false, infoWindow, map.getCenter());
                //     }
                // }
               // else {
                    //window.alert("Lokaatio on " + currentlocation.latitude + ", " + currentlocation.longitude);
                    if (currentlocation != null) {

                        try {
                            map.setCenter({ lat: currentlocation.latitude, lng: currentlocation.longitude });
                        }
                        catch(err){
                            // Browser doesn't support Geolocation
                            handleLocationError(true, infoWindow, map.getCenter());
                        }
                        
                    }
                    else { 
                       window.alert("Something went wrong with your current location. Try again later.")
                        // Browser doesn't support Geolocation
                       handleLocationError(true, infoWindow, map.getCenter());
                    }
               // }
                
                
            });

            //Add markers for each place
            /* --> funktiossa erottelu mik‰ julkinen ja mik‰ yksityinen paikka - eri ikonit:
                    - musta marja: julkinen, sieni: yksityinen, mustikka: kaverit
                --> tarkastelu/muokkauspromptit kun henkilˆ klikkaa markkeria
                --> markerit kiinteit‰
            */

            visiblefindings.forEach(function (find) {
                if (find._idPerson.username === person.username) {//jos oma lˆydˆs, merkit‰‰n sienell‰

                    if(platform == false) {
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            icon: {
                                url: mush_icon, //
                                scaledSize: new google.maps.Size(36, 36)//
                            },
                            title: "PRIVATE: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name

                        });
                    } else {//jos custom ikonit poissa, n‰kyy androidissa
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            content: { background: "#0B5CDE" }, //ei toimi "#0B5CDE"
                            title: "PRIVATE: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name

                        });
                    }
                    // var marker = new google.maps.Marker({
                    //     position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                    //     map: map,
                    //     icon: {//jos custom ikonit poissa, n‰kyy androidissa
                    //         url: mush_icon, //
                    //         scaledSize: new google.maps.Size(36, 36)
                    //     },
                    //     title: "PRIVATE: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name

                    // });

                }
                else if (find._private == 2) {//toisen julkinen lˆydˆs, merkit‰‰n marjalla
                    if (platform == false) {
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            icon: {//
                                url: berry_icon,//
                                scaledSize: new google.maps.Size(46, 46)//
                            },
                            title: "PUBLIC: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                        });
                    }
                    else {//jos custom ikonit poissa, n‰kyy androidissa
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            title: "PUBLIC: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                        });
                    }
                    // var marker = new google.maps.Marker({
                    //     position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                    //     map: map,
                    //     icon: {//
                    //         url: berry_icon,//
                    //         scaledSize: new google.maps.Size(46, 46)//
                    //     },
                    //     title: "PUBLIC: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                    // });

                }
                else {//jos ei oma tai julkinen, niin se on kaverin julkaisema
                    if (platform == false) {
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            icon: {//
                                url: blueberry_icon,//
                                scaledSize: new google.maps.Size(36, 36)//
                            },
                            title: "FRIEND: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                        });
                    }
                    else {//jos custom ikonit poissa, n‰kyy androidissa
                        var marker = new google.maps.Marker({
                            position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                            map: map,
                            title: "FRIEND: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                        });
                    }
                    // var marker = new google.maps.Marker({
                    //     position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                    //     map: map,
                    //     icon: {//
                    //         url: blueberry_icon,//
                    //         scaledSize: new google.maps.Size(36, 36)//
                    //     },
                    //     title: "FRIEND: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                    // });
                }

                //format date
                const isoDateTime = find.datetime;
                const formattedDate = formatShortDate(isoDateTime);

                var info = "Person: " + find._idPerson.username + "\nSpecies: " + find._idSpecies.s_name + "\nCategory: " + find._idSpecies.category + "\nCity: " + find._idPlace.city + "\nCountry: " + find._idPlace.country + "\nCoordinates: " + find._idPlace.lat + ", " + find._idPlace.lng + "\nDate: " + formattedDate + "\nAmount: " + find.amount + "\nMemo: " + find.memo;
                if (find._idPerson.username === person.username) {//jos oma lˆydˆs, annetaan mahdollisuus muokata / poistaa
                    info = info + "\n\nWould you like to edit this information?"
                }
                
                marker.addListener('click', function () {
                    var confirmation = window.confirm(info);
                    if (find._idPerson.username === person.username && confirmation == true) {//jos oma lˆydˆs ja k‰ytt‰j‰ painoi "OK"
                        //avaa edit sivu
                        //var test = window.confirm("Avataan sivu editspot/" + find.id); //find.Id -> UNDEFINED jos Id, tunnistetaan jos id
                        window.location.href = "/editspot/" + find.id; 
                    }
                })
                
            });    
         
        }

        //datetime format
        function formatShortDate(isoDateTime) {
          const date = new Date(isoDateTime);

          const options = { weekday: 'short', day: 'numeric', month: 'long', year: 'numeric'  };
          const formattedDate = date.toLocaleString('en-US', options);

          return formattedDate;
        }



        function placeMarkerAndPanTo(latLng, map, geocoder) {

            newMarker = new google.maps.Marker({
                position: latLng,
                map: map,
                draggable: true
            });


            map.panTo(latLng);

            // window.alert("Tultiin geocodeen: " + latLng)
            const latilng = {
                lat: parseFloat(latLng.lat()),
                lng: parseFloat(latLng.lng()),
            };


            geocoder
                .geocode({ location: latilng })
                .then((response) => {
                    if (response && response.results && response.results.length > 0) {
                        const formattedAddress =
                            response.results[3].formatted_address;
                        // window.alert("Formatted address: " + JSON.stringify(response.results[3].formatted_address))
                        const latlngStr = formattedAddress.split(",", 2);
                        const cityCountry = {
                            city: latlngStr[0],
                            country: latlngStr[1],
                        };

                        setLocationData(latilng, cityCountry); // Set location data

                    } else {
                        window.alert("No results found");
                    }
                })
                .catch((e) =>
                    window.alert("Geocoder failed due to: " + e.message || "Unknown error")
                );
            deleteMarkers();
            markers.push(newMarker);

            return newMarker;

        }

        // Sets the map on all markers in the array.
        function setMapOnAll(map) {
            for (let i = 0; i < markers.length; i++) {
                markers[i].setMap(map);
            }
        }

        // Removes the markers from the map, but keeps them in the array.
        function hideMarkers() {
            setMapOnAll(null);
        }

        //Remove the markers on the map
        function deleteMarkers() {
            hideMarkers();
            markers = [];
        }


        function setLocationData(latilng, cityCountry) {
            //window.alert("Tultiin setLoocationiin")

            const placeInfo = {
                city: cityCountry.city,
                county: cityCountry.country,
                lat: latilng.lat,
                lng: latilng.lng
            }

            document.getElementById("city").value = cityCountry.city;
            document.getElementById("country").value = cityCountry.country;
            document.getElementById("lat").value = JSON.stringify(latilng.lat);
            document.getElementById("lng").value = JSON.stringify(latilng.lng);

            return placeInfo;
        }

        function fetchData() {
            //window.alert("Tultiin fetchDataJS");
            var fetchPlaceInfo = document.getElementById("city").value + ",";
            fetchPlaceInfo += document.getElementById("country").value + ",";
            fetchPlaceInfo += document.getElementById("lat").value + ",";
            fetchPlaceInfo += document.getElementById("lng").value + ",";



            return fetchPlaceInfo;
        }

        function handleLocationError(browserHasGeolocation, infoWindow, pos) {
            infoWindow.setPosition(pos);
            infoWindow.setContent(
                browserHasGeolocation
                    ? "Error: The Geolocation service failed."
                    : "Error: Your browser doesn't support geolocation.",
            );
            infoWindow.open(map);
        }
 
         window.initMap = initMap;
    </script>
</head>
<body>

    <div>

        <div id="googleMap" style="width:100%;height:400px;"></div>

    </div>

    <EditForm Model="newFinding" OnValidSubmit="@NestedValidation">
        <div class="col-lg-4 col-md-12">
            <label for="city"> City </label>
            <InputText id="city" class="form-control" @bind-Value=newFinding._idPlace.city></InputText>
            @if(errorTable!=null)
            {
                <div class="text-warning">@errorTable[0]</div>
            }
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="country"> Country </label>
            <InputText id="country" @bind-Value=newFinding._idPlace.country class="form-control"></InputText>
            @if (errorTable != null)
            {
                <div class="text-warning">@errorTable[1]</div>
            }
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="lat"> Latitude </label>
            <InputNumber id="lat" @bind-Value=newFinding._idPlace.lat class="form-control"></InputNumber>
            
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="lng"> Longitude </label>
            <InputNumber id="lng" @bind-Value=newFinding._idPlace.lng class="form-control"></InputNumber>
            @if (errorTable != null)
            {
                <div class="text-warning">@errorTable[2]</div>
            }
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="findingDate">Add a Date </label>
            <InputDate id="findingDate" @bind-Value=newFinding.datetime class="form-control"></InputDate>
            
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="findindAmount"> Amount </label>
            <InputText id="findindAmount" @bind-Value=newFinding.amount class="form-control"></InputText>
            
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="findingMemo"> Memo </label>
            <InputText id="findingMemo" @bind-Value=newFinding.memo class="form-control">Enter memolog here</InputText>
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="findindPrivate"> Private or not? </label>
            <InputSelect id="findindPrivate" @bind-Value=newFinding._private class="form-control">
                <option value="">Select...</option>
                <option value="0">Private</option>
                <option value="1">Friends</option>
                <option value="2">Public</option>
            </InputSelect>
            @if (errorTable != null)
            {
                <div class="text-warning">@errorTable[3]</div>
            }
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="speciesCategory"> Berries or Mushrooms? </label>
            <InputSelect id="speciesCategory" @bind-Value="newFinding._idSpecies.category" class="form-control">
                <option value="">Select...</option>
                <option>Berries</option>
                <option>Mushrooms</option>
            </InputSelect>
            @if (errorTable != null)
            {
                <div class="text-warning">@errorTable[4]</div>
            }
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="speciesSubCategory"> Species Sub Category </label>
            <InputText id="speciesSubCategory" @bind-Value="newFinding._idSpecies.subCategory" class="form-control">Enter the Sub Category name here</InputText>
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="s_name"> Species Name </label>
            <InputText id="s_name" @bind-Value="newFinding._idSpecies.s_name" class="form-control">Enter the Familiar name name here</InputText>
            @if (errorTable != null)
            {
                <div class="text-warning">@errorTable[5]</div>
            }
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="latin_name"> Latin name </label>
            <InputText id="latin_name" @bind-Value="newFinding._idSpecies.latin_name" class="form-control">Enter the Latin name here</InputText>
        </div>

        <button class="btn btn-primary" type="submit" style="margin-bottom: 50px; margin-top: 20px">Add a Finding!</button>


    </EditForm>

</body>



@code {
        /*NOTES:
        * 
        * Pyyd‰ lupa gps:‰‰n? - android ok!
        * 
        * Etsi ensin k‰ytt‰j‰n lokaatio ja n‰yt‰ se kartassa sek‰ koordinaattikentiss‰ (kentti‰ pit‰‰ pysty‰ muokkaamaan). - ok, android ei ihan
        * 
        * Karttaa pit‰‰ pysty‰ liikuttamaan ja zoomaamaan - OK!
        * 
        * (Anna hakea paikan nimell‰ (ja koordinaateilla?))
        * 
        * Custom pins: vain 1 erilainen pin vai esim. eri kategorioille omat (sieni, marja, kala jne.?) - ok! (paitsi android)
        * 
        * (Opastus pinnipaikalle/osoitteeseen?)
    */

    //private List<string> errorList = new List<string>();
    private string[] errorTable = new string[8];
    private bool isValidated = true;
    private bool platform = false;
    private bool placeExists = false;
    private bool speciesExists = false;
    private PlaceDto existingPlace = new PlaceDto();
    private SpeciesDto existingSpecies = new SpeciesDto();

    private bool _isCheckingLocation;
    private Location currentlocation = new Location();
    private Location cachedlocation;
    private CancellationTokenSource _cancelTokenSource;

    private string placeInfoJS;

    private List<FriendshipDto> friendships { get; set; }
    private List<PersonDto> friends = new List<PersonDto>();
    private List<PersonDto> persons { get; set; }
    private List<FindingDto> allfindings { get; set; }
    private List<FindingDto> visiblefindings = new List<FindingDto>();
    private List<PlaceDto> places { get; set; }
    /* public List<FindingDto> findings { get; private set; } */ //turha?
    private List<SpeciesDto> species { get; set; }

    private PersonDto person { get; set; }
    private FindingDto postFinding = new FindingDto();
    private FindingDto newFinding = new FindingDto()
    {
        _idPlace = new PlaceDto { },
        _idSpecies = new SpeciesDto { },
        _idPerson = new PersonDto { }
    };

    protected override async Task OnInitializedAsync()
    {
        var dateAndTime = DateTime.Now;
        var date = dateAndTime.Date.ToString().Replace("00.00.00", "");
        newFinding.datetime = DateTime.Parse(date);

        //Androidia ja Data Validaatiota varten
        await GetCurrentLocation();
        if(currentlocation == null)
        {
            await GetCachedLocation();
            if(cachedlocation == null)
            {
                Console.WriteLine("ERROR: For unknown reason cannot fetch location");
            }
            currentlocation = cachedlocation;
        }

        //Haetaan kaikki lˆydˆkset, joista suodatetaan julkiseksi merkityt ja henkilˆn omat toiseen listaan
        allfindings = await apiService.GetFindingsAsync();

        // It is not pretty but this is how I got it working the ID thingy
        newFinding._idPlace = new PlaceDto { Id = ObjectId.GenerateNewId().ToString() };
        newFinding._idSpecies = new SpeciesDto { Id = ObjectId.GenerateNewId().ToString() };

        persons = await apiService.GetPersonsAsync();
        species = await apiService.GetSpeciesAsync();
        places = await apiService.GetPlacesAsync();
        friendships = await apiService.GetFriendshipsAsync();

        //etsit‰‰n kaikki kirjautuneen henkilˆn kaverit
        foreach (FriendshipDto friendship in friendships)
        {
            //jos kirjautunut hlˆ on jonkun kaveri (& kaveruus on hyv‰ksytty)
            if ((loginstate.isSingedin.Id == friendship._idPerson.Id || loginstate.isSingedin.Id == friendship._idFriend.Id) && (friendship.friend_accept == 1 && friendship.friend_request == 1))
            {
                if(loginstate.isSingedin.Id == friendship._idPerson.Id)
                {
                    friends.Add(friendship._idFriend);
                }
                else
                {
                    friends.Add(friendship._idPerson);
                }
            }
        }

        newFinding._idPerson = await apiService.GetPersonByIdAsync(loginstate.isSingedin?.Id);

        /*ota kaikki lˆydˆkset ja vertaa niit‰ kirjautuneeseen henkilˆˆn
            - jos henkilˆn oma lˆydˆs, n‰yt‰
            - jos toisen henkilˆn julkinen lˆydˆs, n‰yt‰
            - jos kaverin julkaisema (kavereille), n‰yt‰

            --> n‰m‰ kaikki samaan listaan, joka vied‰‰n parametrina initMap() :lle
                    --> funktiossa erottelu mik‰ julkinen ja mik‰ yksityinen paikka - eri ikonit?
                        - musta marja: julkinen, sieni: yksityinen, mustikka: kaverit
                    --> tarkastelu/muokkauspromptit kun henkilˆ klikkaa markkeria
                    --> markerit kiinte‰t
        */ 

        foreach(FindingDto find in allfindings)
        {
            if(find._idPerson.Id == loginstate.isSingedin.Id || find._private == 2)
            {
                visiblefindings.Add(find);

            }
            else
            {
                foreach(PersonDto friend in friends)
                {
                    if (find._idPerson.Id == friend.Id && find._private == 1)
                    {
                        visiblefindings.Add(find);
                    }
                }
            }
        }

        person = loginstate.isSingedin;

        //mik‰ laite k‰ytˆss‰: Android vai muu (Windows)
        if (DeviceInfo.Current.Platform == DevicePlatform.Android)
        {
            platform = true;
        }
        else { platform = false; }


        await JS.InvokeVoidAsync("initMap", visiblefindings, person, platform, currentlocation);
    }

    //Huom. Form Validation ei tunnista sis‰kk‰isi‰ objekteja, tehd‰‰n t‰m‰ k‰sin
    protected async void NestedValidation() 
    {
        try
        {
            //Fetching the information from JS
            placeInfoJS = await JS.InvokeAsync<string>("fetchData");
            string[] splitFetch = placeInfoJS.Split(',');
            newFinding._idPlace.city = splitFetch[0];
            newFinding._idPlace.country = splitFetch[1];
            newFinding._idPlace.lat = double.Parse(splitFetch[2], System.Globalization.CultureInfo.InvariantCulture);
            newFinding._idPlace.lng = double.Parse(splitFetch[3], System.Globalization.CultureInfo.InvariantCulture);
            //Console.WriteLine($"City: {newFinding._idPlace.city}, Lat: {newFinding._idPlace.lat}, Lng: {newFinding._idPlace.lng}");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception: " + ex);
        }

        //errorList.Clear();
        for(int i = 0; i < errorTable.Length; i++)
        {
            errorTable[i] = null;
        }
        isValidated = true;

        //Finding
        if (newFinding.datetime == null || newFinding.datetime > DateTime.Now)
        {
            var date = DateTime.Now.Date.ToString().Replace("00.00.00", "");
            newFinding.datetime = DateTime.Parse(date);
        }

        if (newFinding._private == null)
        {
            //errorList.Insert(3, "Private is required");
            errorTable[3] = "Private is required";
            isValidated = false;
        }

        //memo ja amount voi puuttua -> jos puuttuu, merkit‰‰n kantaan "-"
        if (string.IsNullOrEmpty(newFinding.memo))
        {
            newFinding.memo = "-";
        }

        if (string.IsNullOrEmpty(newFinding.amount))
        {
            newFinding.amount = "-";
        }

        //Place
        if (string.IsNullOrEmpty(newFinding._idPlace.city))
        {
            // errorList.Insert(0,"City is required");
            errorTable[0] = "City is required";
            isValidated = false;
        }

        if (string.IsNullOrEmpty(newFinding._idPlace.country))
        {
            // errorList.Insert(1,"Country is required");
            errorTable[1] = "Country is required";
            isValidated = false;
        }

        if (newFinding._idPlace.lat == null || newFinding._idPlace.lng == null){

            // errorList.Insert(2,"Coordinates are required");
            errorTable[2] = "Coordinates are required";
            isValidated = false;
        }

        //Species

        if (string.IsNullOrEmpty(newFinding._idSpecies.category))
        {
            // errorList.Insert(4,"Category is required");
            errorTable[4] = "Category is required";
            isValidated = false;
        }

        if (string.IsNullOrEmpty(newFinding._idSpecies.subCategory))
        {//ei pakollinen kentt‰
            newFinding._idSpecies.subCategory = "-";
        }

        if (string.IsNullOrEmpty(newFinding._idSpecies.s_name))
        {
            // errorList.Insert(5,"Name of the species is required");
            errorTable[5] = "Name of the species is required";
            isValidated = false;
        }

        if (string.IsNullOrEmpty(newFinding._idSpecies.latin_name))
        {//ei pakollinen kentt‰
            newFinding._idSpecies.latin_name = "-";
        }


        //onko tiedot oikein
        if(isValidated == true)
        {

            SubmitFinding();
        }

    }

    protected bool CheckIfPlaceExists()
    {
        //Onko olemassa jo kyseist‰ paikkaa ja / tai lajia t‰sm‰lleen samoilla tiedoilla?
        foreach (PlaceDto place in places)
        {
            if (place.city == newFinding._idPlace.city && place.country == newFinding._idPlace.country && place.lat == newFinding._idPlace.lat && place.lng == newFinding._idPlace.lng)
            {
                placeExists = true;
                existingPlace = place;
                break;
            }
        }

        return placeExists;
    }

    protected bool CheckIfSpeciesExists()
    {
        foreach (SpeciesDto spec in species)
        {
            if (spec.category == newFinding._idSpecies.category && spec.subCategory == newFinding._idSpecies.subCategory && spec.s_name == newFinding._idSpecies.s_name && spec.latin_name == newFinding._idSpecies.latin_name)
            {
                speciesExists = true;
                existingSpecies = spec;
                break;
            }
        }
        return speciesExists;
    }

    protected async void SubmitFinding()
    {
        placeExists = CheckIfPlaceExists();

        //jos paikka olemassa, k‰ytet‰‰n vanhaa paikkaa ja uutta paikkaa ei tallenneta kantaan
        if (placeExists)
        {
            newFinding._idPlace = existingPlace;
        }
        else 
        { //uusi paikka lis‰t‰‰n kantaan, tiedot tarkastettu validoinnissa
            await apiService.PostPlaceAsync(newFinding._idPlace); 
        }

        speciesExists = CheckIfSpeciesExists();

        if (speciesExists)
        {
            newFinding._idSpecies = existingSpecies;
        }
        else
        {
            await apiService.PostSpeciesAsync(newFinding._idSpecies);
        }

        await apiService.PostFindingAsync(newFinding);
        NavigationManager.NavigateTo("/ownspots", true);
    }

    //NOTE! TƒMƒ LOGIIKKA TOIMII ANDROIDILLA

    public async Task<Location> GetCachedLocation()
    {
        try
        {
            cachedlocation = await Geolocation.Default.GetLastKnownLocationAsync();

            if (cachedlocation != null)
            {
                Console.WriteLine($"Latitude: {cachedlocation.Latitude}, Longitude: {cachedlocation.Longitude}, Altitude: {cachedlocation.Altitude}");
            }

        }
        catch (FeatureNotSupportedException fnsEx)
        {
            // Handle not supported on device exception
            Console.WriteLine("ERROR: " + fnsEx);
        }
        catch (FeatureNotEnabledException fneEx)
        {
            // Handle not enabled on device exception
            Console.WriteLine("ERROR: " + fneEx);
        }
        catch (PermissionException pEx)
        {
            // Handle permission exception
            Console.WriteLine("ERROR: " + pEx);
        }
        catch (Exception ex)
        {
            // Unable to get location
            Console.WriteLine("ERROR: " + ex);
        }

        return cachedlocation;
    }



    public async Task<Location> GetCurrentLocation()
    {
        try
        {
            _isCheckingLocation = true;

            GeolocationRequest request = new GeolocationRequest(GeolocationAccuracy.Medium, TimeSpan.FromSeconds(10));

            _cancelTokenSource = new CancellationTokenSource();

            currentlocation = await Geolocation.Default.GetLocationAsync(request, _cancelTokenSource.Token);

            if (currentlocation != null){
                Console.WriteLine($"Latitude: {currentlocation.Latitude}, Longitude: {currentlocation.Longitude}, Altitude: {currentlocation.Altitude}");
            }
        }
        catch (FeatureNotSupportedException fnsEx)
        {
            Console.WriteLine("ERROR: " + fnsEx);
        }
        catch(FeatureNotEnabledException fneEx)
        {
            Console.WriteLine("ERROR: " + fneEx);
        }
        catch(PermissionException pEx)
        {
            Console.WriteLine("ERROR: " + pEx);
        }
        catch (Exception ex)
        {
            // Unable to get location
            Console.WriteLine("ERROR: " + ex);
        }
        finally
        {
            _isCheckingLocation = false;
        }
        return currentlocation;
    }

    public void CancelRequest()
    {
        if (_isCheckingLocation && _cancelTokenSource != null && _cancelTokenSource.IsCancellationRequested == false)
            _cancelTokenSource.Cancel();
    }

    

}
