@page "/addspots"
@using Gatherama.Shared
@using Microsoft.Maui.Controls.Maps
@using Microsoft.Maui.Maps
@using System.Net.Http
@using System.Text.Json
@using System.Net.Http.Json;
@using System
@using System.Threading.Tasks
@using Microsoft.Maui.Controls
@using Gatherama.Services
@using MongoDB.Bson;
@using Newtonsoft.Json


@inject IJSRuntime JS
@inject ApiService apiService
@inject NavigationManager NavigationManager
@inject LoginState loginstate


<h1>Add Gathering Spot</h1>

<p>Here you can add your new gathering spot!</p>

<!--MAPS SEKOILUJA:
    Tehdään tänne kartta, joka näyttää vain nykyisen sijainnin ja jossa pystyy syöttämään tiedot löydökselle.
    OwnSpots sivulle tulee kartta, joka näyttää kaikki löydökset mitä on henkilöllä. Sinne myös suodattimet esim lajin perusteella, tai
    että näyttää myös kaverien jakamat paikat.
-->

<head>
    <title>Simple Marker</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBBJYKuoWVsb2MFdchEYIihbAb3pN0fFUg&callback=initMap&libraries=&v=weekly" defer></script>
    <link rel="stylesheet" href="./style.css" />
    <script src="./app.js"></script>


    <script>

        let markers = [];
    
        function initMap(visiblefindings, person) {

            const geocoder = new google.maps.Geocoder();
          
            const map = new google.maps.Map(document.getElementById("googleMap"), {
                zoom: 12,
                center: { lat: 62.8893928527832, lng: 27.6920166015625 }, //alkukeskitys Kuopioon
                //isShowingUser: true, //turha vai Androidille?
                fullscreenControl: false,
                zoomControl: true,
                streetViewControl: false
            });

            const mush_icon = '../Images_index/mushroom_icon.png'; 
            const berry_icon = '../Images_index/berry_icon.png';
            const blueberry_icon = '../Images_index/blueberry_icon.png';

            map.addListener("click", (e) => {

                placeMarkerAndPanTo(e.latLng, map, geocoder);
                //geocodeLatLng(e.latLng, geocoder, map);
            });

            //To pan to current location
            const locationButton = document.createElement("button");

            locationButton.textContent = "Pan to Current Location";
            locationButton.classList.add("custom-map-control-button");
            map.controls[google.maps.ControlPosition.TOP_CENTER].push(locationButton);
            locationButton.addEventListener("click", () => {
                // Try HTML5 geolocation.
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const pos = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                            };

                            //window.alert("Position is: " + pos);
                            // window.alert("Location found.");
                            //infoWindow.open(map);
                            map.setCenter(pos);

                        },
                        () => {
                            handleLocationError(true, infoWindow, map.getCenter());
                        },
                    );
                } else {
                    // Browser doesn't support Geolocation
                    handleLocationError(false, infoWindow, map.getCenter());
                }
            });

            //Add markers for each place
            /* --> funktiossa erottelu mikä julkinen ja mikä yksityinen paikka - eri ikonit:
                    - musta marja: julkinen, sieni: yksityinen, mustikka: kaverit
                --> tarkastelu/muokkauspromptit kun henkilö klikkaa markkeria
                --> markerit kiinteitä
            */

            visiblefindings.forEach(function (find) {
                if (find._idPerson.username === person.username) {//jos oma löydös, merkitään sienellä

                    var marker = new google.maps.Marker({
                        position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                        map: map,
                        icon: {//jos custom ikonit poissa, näkyy androidissa
                            url: mush_icon, //
                            scaledSize: new google.maps.Size(36, 36)//
                        },
                        title: "PRIVATE: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name

                    });

                }
                else if (find._private == 2) {//toisen julkinen löydös, merkitään marjalla
                    var marker = new google.maps.Marker({
                        position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                        map: map,
                        icon: {//
                            url: berry_icon,//
                            scaledSize: new google.maps.Size(46, 46)//
                        },
                        title: "PUBLIC: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                    });

                }
                else {//jos ei oma tai julkinen, niin se on kaverin julkaisema
                    var marker = new google.maps.Marker({
                        position: { lat: find._idPlace.lat, lng: find._idPlace.lng },
                        map: map,
                        icon: {//
                            url: blueberry_icon,//
                            scaledSize: new google.maps.Size(36, 36)//
                        },
                        title: "FRIEND: \nCity: " + find._idPlace.city + ", \nSpecies: " + find._idSpecies.s_name
                    });
                }

                //format date
                const isoDateTime = find.datetime;
                const formattedDate = formatShortDate(isoDateTime);

                var info = "Person: " + find._idPerson.username + "\nSpecies: " + find._idSpecies.s_name + "\nCategory: " + find._idSpecies.category + "\nCity: " + find._idPlace.city + "\nCountry: " + find._idPlace.country + "\nCoordinates: " + find._idPlace.lat + ", " + find._idPlace.lng + "\nDate: " + formattedDate + "\nAmount: " + find.amount + "\nMemo: " + find.memo;
                if (find._idPerson.username === person.username) {//jos oma löydös, annetaan mahdollisuus muokata / poistaa
                    info = info + "\n\nWould you like to edit this information?"
                }
                
                marker.addListener('click', function () {
                    var confirmation = window.confirm(info);
                    if (find._idPerson.username === person.username && confirmation == true) {//jos oma löydös ja käyttäjä painoi "OK"
                        //avaa edit sivu
                        //var test = window.confirm("Avataan sivu editspot/" + find.id); //find.Id -> UNDEFINED jos Id, tunnistetaan jos id
                        window.location.href = "/editspot/" + find.id; 
                    }
                })
                
            });    
         
        }

        //datetime format
        function formatShortDate(isoDateTime) {
          const date = new Date(isoDateTime);

          const options = { weekday: 'short', day: 'numeric', month: 'long', year: 'numeric'  };
          const formattedDate = date.toLocaleString('en-US', options);

          return formattedDate;
        }



        function placeMarkerAndPanTo(latLng, map, geocoder) {

            newMarker = new google.maps.Marker({
                position: latLng,
                map: map,
                draggable: true
            });


            map.panTo(latLng);

            // window.alert("Tultiin geocodeen: " + latLng)
            const latilng = {
                lat: parseFloat(latLng.lat()),
                lng: parseFloat(latLng.lng()),
            };


            geocoder
                .geocode({ location: latilng })
                .then((response) => {
                    if (response && response.results && response.results.length > 0) {
                        const formattedAddress =
                            response.results[3].formatted_address;
                        // window.alert("Formatted address: " + JSON.stringify(response.results[3].formatted_address))
                        const latlngStr = formattedAddress.split(",", 2);
                        const cityCountry = {
                            city: latlngStr[0],
                            country: latlngStr[1],
                        };

                        setLocationData(latilng, cityCountry); // Set location data

                    } else {
                        window.alert("No results found");
                    }
                })
                .catch((e) =>
                    window.alert("Geocoder failed due to: " + e.message || "Unknown error")
                );
            deleteMarkers();
            markers.push(newMarker);

            return newMarker;

        }

        // Sets the map on all markers in the array.
        function setMapOnAll(map) {
            for (let i = 0; i < markers.length; i++) {
                markers[i].setMap(map);
            }
        }

        // Removes the markers from the map, but keeps them in the array.
        function hideMarkers() {
            setMapOnAll(null);
        }

        //Remove the markers on the map
        function deleteMarkers() {
            hideMarkers();
            markers = [];
        }


        function setLocationData(latilng, cityCountry) {
            //window.alert("Tultiin setLoocationiin")

            const placeInfo = {
                city: cityCountry.city,
                county: cityCountry.country,
                lat: latilng.lat,
                lng: latilng.lng
            }

            document.getElementById("city").value = cityCountry.city;
            document.getElementById("country").value = cityCountry.country;
            document.getElementById("lat").value = JSON.stringify(latilng.lat);
            document.getElementById("lng").value = JSON.stringify(latilng.lng);

            return placeInfo;
        }

        function fetchData() {
            //window.alert("Tultiin fetchDataJS");
            var fetchPlaceInfo = document.getElementById("city").value + ",";
            fetchPlaceInfo += document.getElementById("country").value + ",";
            fetchPlaceInfo += document.getElementById("lat").value + ",";
            fetchPlaceInfo += document.getElementById("lng").value + ",";



            return fetchPlaceInfo;
        }

        function handleLocationError(browserHasGeolocation, infoWindow, pos) {
            infoWindow.setPosition(pos);
            infoWindow.setContent(
                browserHasGeolocation
                    ? "Error: The Geolocation service failed."
                    : "Error: Your browser doesn't support geolocation.",
            );
            infoWindow.open(map);
        }
 
         window.initMap = initMap;
    </script>
</head>
<body>

    <div>

        <div id="googleMap" style="width:100%;height:400px;"></div>

    </div>

    <EditForm Model="newFinding" OnValidSubmit="@SubmitFinding">
        <DataAnnotationsValidator />
        <div class="col-lg-4 col-md-12">
            <label for="city"> City </label>
            <InputText id="city" class="form-control" @bind-Value=newFinding._idPlace.city></InputText>
            <ValidationMessage For="@(() => newFinding._idPlace.city)" class="text-warning"/>
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="country"> Country </label>
            <InputText id="country" @bind-Value=newFinding._idPlace.country class="form-control"></InputText>
            <ValidationMessage For="@(() => newFinding._idPlace.country)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="lat"> Latitude </label>
            <InputNumber id="lat" @bind-Value=newFinding._idPlace.lat class="form-control"></InputNumber>
            <ValidationMessage For="@(() => newFinding._idPlace.lat)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="lng"> Longitude </label>
            <InputNumber id="lng" @bind-Value=newFinding._idPlace.lng class="form-control"></InputNumber>
            <ValidationMessage For="@(() => newFinding._idPlace.lng)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="findingDate">Add a Date </label>
            <InputDate id="findingDate" @bind-Value=newFinding.datetime class="form-control"></InputDate>
            <ValidationMessage For="@(() => newFinding.datetime)" class="text-warning" />
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="findindAmount"> Amount </label>
            <InputText id="findindAmount" @bind-Value=newFinding.amount class="form-control"></InputText>
            <ValidationMessage For="@(() => newFinding.amount)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="findingMemo"> Memo </label>
            <InputText id="findingMemo" @bind-Value=newFinding.memo class="form-control">Enter memolog here</InputText>
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="findindPrivate"> Private or not? </label>
            <InputSelect id="findindPrivate" @bind-Value=newFinding._private class="form-control">
                <option value="">Select...</option>
                <option value="0">Private</option>
                <option value="1">Friends</option>
                <option value="2">Public</option>
            </InputSelect>
            <ValidationMessage For="@(() => newFinding._private)" class="text-warning" />
        </div>

        <div class="col-lg-4 col-md-12">
            <label for="speciesCategory"> Berries or Mushrooms? </label>
            <InputSelect id="speciesCategory" @bind-Value="newFinding._idSpecies.category" class="form-control">
                <option value="">Select...</option>
                <option>Berries</option>
                <option>Mushrooms</option>
            </InputSelect>
            <ValidationMessage For="@(() => newFinding._idSpecies.category)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="speciesSubCategory"> Species Sub Category </label>
            <InputText id="speciesSubCategory" @bind-Value="newFinding._idSpecies.subCategory" class="form-control">Enter the Sub Category name here</InputText>
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="s_name"> Species Name </label>
            <InputText id="s_name" @bind-Value="newFinding._idSpecies.s_name" class="form-control">Enter the Familiar name name here</InputText>
            <ValidationMessage For="@(() => newFinding._idSpecies.s_name)" class="text-warning" />
        </div>
        <div class="col-lg-4 col-md-12">
            <label for="latin_name"> Latin name </label>
            <InputText id="latin_name" @bind-Value="newFinding._idSpecies.latin_name" class="form-control">Enter the Latin name here</InputText>
        </div>

        <button class="btn btn-primary" type="submit" style="margin-bottom: 50px; margin-top: 20px">Add a Finding!</button>


    </EditForm>

 

</body>



@code {
        /*NOTES:
        * 
        * Pyydä lupa gps:ään? - android ok!
        * 
        * Etsi ensin käyttäjän lokaatio ja näytä se kartassa sekä koordinaattikentissä (kenttiä pitää pystyä muokkaamaan). - ok, android ei ihan
        * 
        * Karttaa pitää pystyä liikuttamaan ja zoomaamaan - OK!
        * 
        * (Anna hakea paikan nimellä (ja koordinaateilla?))
        * 
        * Custom pins: vain 1 erilainen pin vai esim. eri kategorioille omat (sieni, marja, kala jne.?) - ok! (paitsi android)
        * 
        * (Opastus pinnipaikalle/osoitteeseen?)
    */
    private CancellationTokenSource _cancelTokenSource;
    private bool _isCheckingLocation;
    Location currentlocation = new Location();
    Location cachedlocation;


    //////
    //TESTI
    private ValidationMessageStore? messagestore;
    private EditContext? editContext;

    /////




    private List<FriendshipDto> friendships { get; set; }
    private List<PersonDto> friends = new List<PersonDto>();
    public List<FindingDto> allfindings { get; private set; }
    public List<FindingDto> visiblefindings = new List<FindingDto>();
    public List<PlaceDto> places { get; private set; }
    public List<FindingDto> findings { get; private set; }
    public List<PersonDto> persons { get; private set; }
    public List<SpeciesDto> species { get; private set; }
    public PersonDto person { get; private set; }

    private FindingDto newFinding = new FindingDto()
    {
        _idPlace = new PlaceDto { city = "", country = "", lat = 0, lng = 0 },
        _idSpecies = new SpeciesDto { category = "", subCategory = "", s_name = "", latin_name = "" },
        _idPerson = new PersonDto { }

    };

    private FindingDto postFinding = new FindingDto();

    string placeInfoJS;

    protected override async Task OnInitializedAsync()
    {
        var dateAndTime = DateTime.Now;
        var date = dateAndTime.Date.ToString().Replace("00.00.00", "");
        newFinding.datetime = DateTime.Parse(date);


        // await GetCurrentLocation();
        // if(currentlocation == null)
        // {
        //     await GetCachedLocation();
        //     if(cachedlocation == null)
        //     {
        //         Console.WriteLine("ERROR: For unknown reason cannot fetch location");
        //     }
        //     currentlocation = cachedlocation;
        // }

        //Haetaan kaikki löydökset, joista suodatetaan julkiseksi merkityt ja henkilön omat toiseen listaan
        allfindings = await apiService.GetFindingsAsync();

        // It is not pretty but this is how I got it working the ID thingy
        newFinding._idPlace = new PlaceDto { Id = ObjectId.GenerateNewId().ToString() };
        newFinding._idSpecies = new SpeciesDto { Id = ObjectId.GenerateNewId().ToString() };

        persons = await apiService.GetPersonsAsync();
        species = await apiService.GetSpeciesAsync();
        places = await apiService.GetPlacesAsync();
        friendships = await apiService.GetFriendshipsAsync();

        //etsitään kaikki kirjautuneen henkilön kaverit
        foreach (FriendshipDto friendship in friendships)
        {
            //jos kirjautunut hlö on jonkun kaveri (& kaveruus on hyväksytty)
            if ((loginstate.isSingedin.Id == friendship._idPerson.Id || loginstate.isSingedin.Id == friendship._idFriend.Id) && (friendship.friend_accept == 1 && friendship.friend_request == 1))
            {
                if(loginstate.isSingedin.Id == friendship._idPerson.Id)
                {
                    friends.Add(friendship._idFriend);
                }
                else
                {
                    friends.Add(friendship._idPerson);
                }
            }
        }

        newFinding._idPerson = await apiService.GetPersonByIdAsync(loginstate.isSingedin?.Id);

        /*ota kaikki löydökset ja vertaa niitä kirjautuneeseen henkilöön
            - jos henkilön oma löydös, näytä
            - jos toisen henkilön julkinen löydös, näytä
            - jos kaverin julkaisema (kavereille), näytä

            --> nämä kaikki samaan listaan, joka viedään parametrina initMap() :lle

                --> funktiossa erottelu mikä julkinen ja mikä yksityinen paikka - eri ikonit?
                    - musta marja: julkinen, sieni: yksityinen, mustikka: kaverit
                --> tarkastelu/muokkauspromptit kun henkilö klikkaa markkeria
                --> markerit kiinteät
        */ 

        foreach(FindingDto find in allfindings)
        {
            if(find._idPerson.Id == loginstate.isSingedin.Id || find._private == 2)
            {
                visiblefindings.Add(find);

            }
            else
            {
                foreach(PersonDto friend in friends)
                {
                    if (find._idPerson.Id == friend.Id && find._private == 1)
                    {
                        visiblefindings.Add(find);
                    }
                }
            }
        }

        person = loginstate.isSingedin;


        //////////TESTIÄ
        editContext = new EditContext(newFinding);
        messagestore = new(editContext);
        ////////////

        await JS.InvokeVoidAsync("initMap", visiblefindings, person);

    }

    protected async void SubmitFinding()
    {
        //Fetching the information from JS
        placeInfoJS = await JS.InvokeAsync<string>("fetchData");
        string[] splitFetch = placeInfoJS.Split(',');
        newFinding._idPlace.city = splitFetch[0];
        newFinding._idPlace.country = splitFetch[1];
        newFinding._idPlace.lat = double.Parse(splitFetch[2], System.Globalization.CultureInfo.InvariantCulture);
        newFinding._idPlace.lng = double.Parse(splitFetch[3], System.Globalization.CultureInfo.InvariantCulture);

        //Tarkista että kaikissa muuttujissa on arvot!! muuten error



        Console.WriteLine($"City: {newFinding._idPlace.city}, Lat: {newFinding._idPlace.lat}, Lng: {newFinding._idPlace.lng}");

        if(newFinding._idPlace.city == null || newFinding._idPlace.country == null || newFinding._idPlace.lat == null || newFinding._idPlace.lng == null)
        {
            //jos käyttäjä on poistanut jtn näistä generoiduista tiedoista
            if (newFinding._idPlace.city == null)
            {
                //ModelState.AddModelError("newFinding._idPlace.city", "City error");
                messagestore.Add(() => newFinding._idPlace.city, "City error");
            } 

            if (newFinding._idPlace.country == null)
            {

            }

            if (newFinding._idPlace.lat == null)
            {
                
            }

            if (newFinding._idPlace.lng == null)
            {

            }

        }
        await apiService.PostPlaceAsync(newFinding._idPlace);


        //latinalainen nimi ja alakatergoria voi puuttua -> merkitään niihin "-", jotta kanta ei kaadu
        //Huom. Form Validation ei tunnista sisäkkäisiä objekteja, tehdään tämä käsin
        if (newFinding._idSpecies.category == null || newFinding._idSpecies.subCategory == null || newFinding._idSpecies.s_name == null || newFinding._idSpecies.latin_name == null )
        {
            if (newFinding._idSpecies.category == null) //Poista purkka?
            {
                newFinding._idSpecies.category = "Unknown";
            }

            if (newFinding._idSpecies.subCategory == null)
            {
                newFinding._idSpecies.subCategory = "-";
            }

            if (newFinding._idSpecies.s_name == null) //Poista purkka?
            {
                newFinding._idSpecies.s_name = "Unknown";
            }

            if (newFinding._idSpecies.latin_name == null)
            {
                newFinding._idSpecies.latin_name = "-";
            }

        }
        await apiService.PostSpeciesAsync(newFinding._idSpecies);

        //memo voi puuttua -> jos puuttuu, merkitään kantaan "-"
        if (newFinding.memo == null) 
        {
            newFinding.memo = "-";
        }
        await apiService.PostFindingAsync(newFinding);
        NavigationManager.NavigateTo("/ownspots", true);
    }

    //NOTE! TÄMÄ LOGIIKKA TOIMI ANDROIDILLA


    // public async Task<Location> GetCachedLocation()
    // {
    //     try
    //     {
    //         cachedlocation = await Geolocation.Default.GetLastKnownLocationAsync();

    //         if (cachedlocation != null)
    //         {
    //             Console.WriteLine($"Latitude: {cachedlocation.Latitude}, Longitude: {cachedlocation.Longitude}, Altitude: {cachedlocation.Altitude}");
    //             // myLat = cachedlocation.Latitude;
    //             // myLng = cachedlocation.Longitude;
    //         }

    //     }
    //     catch (FeatureNotSupportedException fnsEx)
    //     {
    //         // Handle not supported on device exception
    //         Console.WriteLine("ERROR: " + fnsEx);
    //     }
    //     catch (FeatureNotEnabledException fneEx)
    //     {
    //         // Handle not enabled on device exception
    //         Console.WriteLine("ERROR: " + fneEx);
    //     }
    //     catch (PermissionException pEx)
    //     {
    //         // Handle permission exception
    //         Console.WriteLine("ERROR: " + pEx);
    //     }
    //     catch (Exception ex)
    //     {
    //         // Unable to get location
    //         Console.WriteLine("ERROR: " + ex);
    //     }

    //     return cachedlocation;
    // }



    // public async Task<Location> GetCurrentLocation()
    // {
    //     try
    //     {
    //         _isCheckingLocation = true;

    //         GeolocationRequest request = new GeolocationRequest(GeolocationAccuracy.Medium, TimeSpan.FromSeconds(10));

    //         _cancelTokenSource = new CancellationTokenSource();

    //         currentlocation = await Geolocation.Default.GetLocationAsync(request, _cancelTokenSource.Token);

    //         if (currentlocation != null){
    //             Console.WriteLine($"Latitude: {currentlocation.Latitude}, Longitude: {currentlocation.Longitude}, Altitude: {currentlocation.Altitude}");
    //             // myLat = currentlocation.Latitude;
    //             // myLng = currentlocation.Longitude;

    //         }


    //     }
    //     catch (FeatureNotSupportedException fnsEx)
    //     {
    //         Console.WriteLine("ERROR: " + fnsEx);
    //     }
    //     catch(FeatureNotEnabledException fneEx)
    //     {
    //         Console.WriteLine("ERROR: " + fneEx);
    //     }
    //     catch(PermissionException pEx)
    //     {
    //         Console.WriteLine("ERROR: " + pEx);
    //     }
    //     catch (Exception ex)
    //     {
    //         // Unable to get location
    //         Console.WriteLine("ERROR: " + ex);
    //     }
    //     finally
    //     {
    //         _isCheckingLocation = false;
    //     }
    //     return currentlocation;
    // }

    public void CancelRequest()
    {
        if (_isCheckingLocation && _cancelTokenSource != null && _cancelTokenSource.IsCancellationRequested == false)
            _cancelTokenSource.Cancel();
    }

}
